<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · MriResearchTools.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://korbinian90.github.io/MriResearchTools.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>MriResearchTools.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/korbinian90/MriResearchTools.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MriResearchTools"><a class="docs-heading-anchor" href="#MriResearchTools">MriResearchTools</a><a id="MriResearchTools-1"></a><a class="docs-heading-anchor-permalink" href="#MriResearchTools" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/korbinian90/MriResearchTools.jl">MriResearchTools</a>.</p><ul><li><a href="#MriResearchTools.NumART2star-Union{Tuple{T}, Tuple{AbstractArray{T, 4}, Any}} where T"><code>MriResearchTools.NumART2star</code></a></li><li><a href="#MriResearchTools.RSS-Tuple{Any}"><code>MriResearchTools.RSS</code></a></li><li><a href="#MriResearchTools.brain_mask"><code>MriResearchTools.brain_mask</code></a></li><li><a href="#MriResearchTools.calculateB0_unwrapped-Tuple{Any, Any, Any}"><code>MriResearchTools.calculateB0_unwrapped</code></a></li><li><a href="#MriResearchTools.estimatenoise-Tuple{AbstractArray}"><code>MriResearchTools.estimatenoise</code></a></li><li><a href="#MriResearchTools.estimatequantile-Tuple{Any, Any}"><code>MriResearchTools.estimatequantile</code></a></li><li><a href="#MriResearchTools.gaussiansmooth3d"><code>MriResearchTools.gaussiansmooth3d</code></a></li><li><a href="#MriResearchTools.gaussiansmooth3d!"><code>MriResearchTools.gaussiansmooth3d!</code></a></li><li><a href="#MriResearchTools.gaussiansmooth3d_phase"><code>MriResearchTools.gaussiansmooth3d_phase</code></a></li><li><a href="#MriResearchTools.getHIP-Tuple{Any, Any}"><code>MriResearchTools.getHIP</code></a></li><li><a href="#MriResearchTools.getVSM"><code>MriResearchTools.getVSM</code></a></li><li><a href="#MriResearchTools.getsensitivity"><code>MriResearchTools.getsensitivity</code></a></li><li><a href="#MriResearchTools.header-Tuple{NIfTI.NIVolume}"><code>MriResearchTools.header</code></a></li><li><a href="#MriResearchTools.homodyne"><code>MriResearchTools.homodyne</code></a></li><li><a href="#MriResearchTools.homodyne!"><code>MriResearchTools.homodyne!</code></a></li><li><a href="#MriResearchTools.laplacianunwrap"><code>MriResearchTools.laplacianunwrap</code></a></li><li><a href="#MriResearchTools.laplacianunwrap!"><code>MriResearchTools.laplacianunwrap!</code></a></li><li><a href="#MriResearchTools.makehomogeneous"><code>MriResearchTools.makehomogeneous</code></a></li><li><a href="#MriResearchTools.makehomogeneous"><code>MriResearchTools.makehomogeneous</code></a></li><li><a href="#MriResearchTools.makehomogeneous!"><code>MriResearchTools.makehomogeneous!</code></a></li><li><a href="#MriResearchTools.mask_from_voxelquality"><code>MriResearchTools.mask_from_voxelquality</code></a></li><li><a href="#MriResearchTools.mcpc3ds-Tuple{AbstractArray{&lt;:Real}}"><code>MriResearchTools.mcpc3ds</code></a></li><li><a href="#MriResearchTools.phase_based_mask-Tuple{Any}"><code>MriResearchTools.phase_based_mask</code></a></li><li><a href="#MriResearchTools.r2s_from_t2s-Tuple{Any}"><code>MriResearchTools.r2s_from_t2s</code></a></li><li><a href="#MriResearchTools.readmag-Tuple{Any}"><code>MriResearchTools.readmag</code></a></li><li><a href="#MriResearchTools.readphase-Tuple{Any}"><code>MriResearchTools.readphase</code></a></li><li><a href="#MriResearchTools.robustmask"><code>MriResearchTools.robustmask</code></a></li><li><a href="#MriResearchTools.robustmask!"><code>MriResearchTools.robustmask!</code></a></li><li><a href="#MriResearchTools.robustrescale-Tuple{Any, Any, Any}"><code>MriResearchTools.robustrescale</code></a></li><li><a href="#MriResearchTools.savenii-Tuple{AbstractArray, Any}"><code>MriResearchTools.savenii</code></a></li><li><a href="#MriResearchTools.to_dim-Tuple{Real, Int64}"><code>MriResearchTools.to_dim</code></a></li><li><a href="#MriResearchTools.write_emptynii-Tuple{Any, Any}"><code>MriResearchTools.write_emptynii</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.NumART2star-Union{Tuple{T}, Tuple{AbstractArray{T, 4}, Any}} where T" href="#MriResearchTools.NumART2star-Union{Tuple{T}, Tuple{AbstractArray{T, 4}, Any}} where T"><code>MriResearchTools.NumART2star</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NumART2star(image::AbstractArray{T,4}, TEs) where T</code></pre><p>Performs T2* calculation on 4D-multi-echo magnitude data. https://doi.org/10.1002/mrm.10283</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/methods.jl#L16-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.RSS-Tuple{Any}" href="#MriResearchTools.RSS-Tuple{Any}"><code>MriResearchTools.RSS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RSS(mag; dims=ndims(mag))</code></pre><p>Performs root-sum-of-squares combination along the last dimension of <code>mag</code>. The dimension can be specificed via the <code>dims</code> keyword argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/utility.jl#L85-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.brain_mask" href="#MriResearchTools.brain_mask"><code>MriResearchTools.brain_mask</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">brain_mask(mask)</code></pre><p>Tries to extract the brain from a mask with skull and a gap between brain and skull.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mask = robustmask(mag)
julia&gt; brain = brain_mask(mask)</code></pre><p>See also <a href="#MriResearchTools.robustmask"><code>robustmask</code></a>, <a href="@ref"><code>ROMEO.romeovoxelquality</code></a>, <a href="#MriResearchTools.phase_based_mask-Tuple{Any}"><code>phase_based_mask</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/masking.jl#L120-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.calculateB0_unwrapped-Tuple{Any, Any, Any}" href="#MriResearchTools.calculateB0_unwrapped-Tuple{Any, Any, Any}"><code>MriResearchTools.calculateB0_unwrapped</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculateB0_unwrapped(unwrapped_phase, mag, TEs)</code></pre><p>Calculates B0 in [Hz] from unwrapped phase. TEs in [ms]. The phase offsets have to be removed prior.</p><p>See also <a href="#MriResearchTools.mcpc3ds-Tuple{AbstractArray{&lt;:Real}}"><code>mcpc3ds</code></a> and <a href="@ref"><code>romeo</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/romeofunctions.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.estimatenoise-Tuple{AbstractArray}" href="#MriResearchTools.estimatenoise-Tuple{AbstractArray}"><code>MriResearchTools.estimatenoise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">estimatenoise(image::AbstractArray)</code></pre><p>Estimates the noise from the corners of the image. It assumes that at least one corner is without signal and only contains noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/utility.jl#L43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.estimatequantile-Tuple{Any, Any}" href="#MriResearchTools.estimatequantile-Tuple{Any, Any}"><code>MriResearchTools.estimatequantile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">estimatequantile(array, p)</code></pre><p>Quickly estimates the quantile <code>p</code> of a possibly large array by using a subset of the data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/utility.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.gaussiansmooth3d" href="#MriResearchTools.gaussiansmooth3d"><code>MriResearchTools.gaussiansmooth3d</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gaussiansmooth3d(image)

gaussiansmooth3d(image, sigma=[5,5,5];
    mask=nothing,
    nbox=ifelse(isnothing(mask), 3, 6), 
    weight=nothing, dims=1:min(ndims(image),3), 
    boxsizes=getboxsizes.(sigma, nbox)
    )</code></pre><p>Performs Gaussian smoothing on <code>image</code> with <code>sigma</code> as standard deviation of the Gaussian. By application of <code>nbox</code> times running average filters in each dimension. The length of <code>sigma</code> and the length of the <code>dims</code> that are smoothed have to match. (Default <code>3</code>)</p><p>Optional arguments:</p><ul><li><code>mask</code>: Smoothing can be performed using a mask to inter-/extrapolate missing values.</li><li><code>nbox</code>: Number of box applications. Default is <code>3</code> for normal smoothing and <code>6</code> for masked smoothing.</li><li><code>weight</code>: Apply weighted smoothing. Either weighted or masked smoothing can be porformed.</li><li><code>dims</code>: Specify which dims should be smoothed. Corresponds to manually looping of the other dimensions.</li><li><code>boxizes</code>: Manually specify the boxsizes, not using the provided sigma. <code>length(boxsizes)==length(dims) &amp;&amp; length(boxsizes[1])==nbox</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/smoothing.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.gaussiansmooth3d!" href="#MriResearchTools.gaussiansmooth3d!"><code>MriResearchTools.gaussiansmooth3d!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gaussiansmooth3d(image)

gaussiansmooth3d(image, sigma=[5,5,5];
    mask=nothing,
    nbox=ifelse(isnothing(mask), 3, 6), 
    weight=nothing, dims=1:min(ndims(image),3), 
    boxsizes=getboxsizes.(sigma, nbox)
    )</code></pre><p>Performs Gaussian smoothing on <code>image</code> with <code>sigma</code> as standard deviation of the Gaussian. By application of <code>nbox</code> times running average filters in each dimension. The length of <code>sigma</code> and the length of the <code>dims</code> that are smoothed have to match. (Default <code>3</code>)</p><p>Optional arguments:</p><ul><li><code>mask</code>: Smoothing can be performed using a mask to inter-/extrapolate missing values.</li><li><code>nbox</code>: Number of box applications. Default is <code>3</code> for normal smoothing and <code>6</code> for masked smoothing.</li><li><code>weight</code>: Apply weighted smoothing. Either weighted or masked smoothing can be porformed.</li><li><code>dims</code>: Specify which dims should be smoothed. Corresponds to manually looping of the other dimensions.</li><li><code>boxizes</code>: Manually specify the boxsizes, not using the provided sigma. <code>length(boxsizes)==length(dims) &amp;&amp; length(boxsizes[1])==nbox</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/smoothing.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.gaussiansmooth3d_phase" href="#MriResearchTools.gaussiansmooth3d_phase"><code>MriResearchTools.gaussiansmooth3d_phase</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gaussiansmooth3d_phase(phase, sigma=[5,5,5]; weight=1, kwargs...)</code></pre><p>Smoothes the phase via complex smoothing. A weighting image can be given. The same keyword arguments are supported as in <code>gaussiansmooth3d</code>:</p><pre><code class="nohighlight hljs">gaussiansmooth3d(image)

gaussiansmooth3d(image, sigma=[5,5,5];
    mask=nothing,
    nbox=ifelse(isnothing(mask), 3, 6), 
    weight=nothing, dims=1:min(ndims(image),3), 
    boxsizes=getboxsizes.(sigma, nbox)
    )</code></pre><p>Performs Gaussian smoothing on <code>image</code> with <code>sigma</code> as standard deviation of the Gaussian. By application of <code>nbox</code> times running average filters in each dimension. The length of <code>sigma</code> and the length of the <code>dims</code> that are smoothed have to match. (Default <code>3</code>)</p><p>Optional arguments:</p><ul><li><code>mask</code>: Smoothing can be performed using a mask to inter-/extrapolate missing values.</li><li><code>nbox</code>: Number of box applications. Default is <code>3</code> for normal smoothing and <code>6</code> for masked smoothing.</li><li><code>weight</code>: Apply weighted smoothing. Either weighted or masked smoothing can be porformed.</li><li><code>dims</code>: Specify which dims should be smoothed. Corresponds to manually looping of the other dimensions.</li><li><code>boxizes</code>: Manually specify the boxsizes, not using the provided sigma. <code>length(boxsizes)==length(dims) &amp;&amp; length(boxsizes[1])==nbox</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/smoothing.jl#L38-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.getHIP-Tuple{Any, Any}" href="#MriResearchTools.getHIP-Tuple{Any, Any}"><code>MriResearchTools.getHIP</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getHIP(mag, phase; echoes=[1,2])

getHIP(compl; echoes=[1,2])</code></pre><p>Calculates the Hermitian Inner Product between the specified echoes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/utility.jl#L172-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.getVSM" href="#MriResearchTools.getVSM"><code>MriResearchTools.getVSM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getVSM(B0, rbw, dim, threshold=5.0)</code></pre><p>Calculates a voxel-shift-map. B0 is given in [Hz]. rbw is the receiverbandwidth or PixelBandwidth in [Hz]. dim is the dimension of the readout (in which the distortion occurs)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/VSMbasedunwarping.jl#L42-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.getsensitivity" href="#MriResearchTools.getsensitivity"><code>MriResearchTools.getsensitivity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getsensitivity(mag; sigma, nbox=15)

getsensitivity(mag, pixdim; sigma_mm=7, nbox=15)

getsensitivity(mag::NIVolume, datatype=eltype(mag); sigma_mm=7, nbox=15)</code></pre><p>Calculates the bias field using the <code>boxsegment</code> approach. It assumes that there is a &quot;main tissue&quot; that is present in most areas of the object. Published in <a href="https://doi.org/10.1016/j.neuroimage.2021.118175">CLEAR-SWI</a>.</p><p>See also <a href="#MriResearchTools.makehomogeneous"><code>makehomogeneous</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/intensitycorrection.jl#L67-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.header-Tuple{NIfTI.NIVolume}" href="#MriResearchTools.header-Tuple{NIfTI.NIVolume}"><code>MriResearchTools.header</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">header(v::NIVolume)</code></pre><p>Returns a copy of the header with the orientation information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; vol = readmag(&quot;image.nii&quot;)
julia&gt; hdr = header(vol)
julia&gt; savenii(vol .+ 10, &quot;vol10.nii&quot;; header=hdr)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/niftihandling.jl#L71-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.homodyne" href="#MriResearchTools.homodyne"><code>MriResearchTools.homodyne</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">homodyne(mag, phase)

homodyne(mag, phase; dims, sigma)

homodyne(I; kwargs...)</code></pre><p>Performs homodyne filtering via division of complex complex smoothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/methods.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.homodyne!" href="#MriResearchTools.homodyne!"><code>MriResearchTools.homodyne!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">homodyne(mag, phase)

homodyne(mag, phase; dims, sigma)

homodyne(I; kwargs...)</code></pre><p>Performs homodyne filtering via division of complex complex smoothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/methods.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.laplacianunwrap" href="#MriResearchTools.laplacianunwrap"><code>MriResearchTools.laplacianunwrap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">laplacianunwrap(ϕ::AbstractArray)</code></pre><p>Performs laplacian unwrapping on the input phase. (1D - 4D) The phase has to be scaled to radians. The implementation is close to the original publication: Schofield and Zhu 2003, https://doi.org/10.1364/OL.28.001194. It is not the fastest implementation of laplacian unwrapping (doesn&#39;t use discrete laplacian).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/laplacianunwrapping.jl#L23-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.laplacianunwrap!" href="#MriResearchTools.laplacianunwrap!"><code>MriResearchTools.laplacianunwrap!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">laplacianunwrap(ϕ::AbstractArray)</code></pre><p>Performs laplacian unwrapping on the input phase. (1D - 4D) The phase has to be scaled to radians. The implementation is close to the original publication: Schofield and Zhu 2003, https://doi.org/10.1364/OL.28.001194. It is not the fastest implementation of laplacian unwrapping (doesn&#39;t use discrete laplacian).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/laplacianunwrapping.jl#L23-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.makehomogeneous" href="#MriResearchTools.makehomogeneous"><code>MriResearchTools.makehomogeneous</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">makehomogeneous(mag::NIVolume; sigma_mm=7, nbox=15)</code></pre><p>Homogeneity correction for NIVolume from NIfTI files.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>sigma_mm</code>: sigma size for smoothing to obtain bias field. Takes NIfTI voxel size into account</li><li><code>nbox</code>: Number of boxes in each dimension for the box-segmentation step.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/intensitycorrection.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.makehomogeneous" href="#MriResearchTools.makehomogeneous"><code>MriResearchTools.makehomogeneous</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">makehomogeneous(mag; sigma, nbox=15)</code></pre><p>Homogeneity correction of 3D arrays. 4D volumes are corrected using the first 3D volume to obtain the bias field.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>sigma</code>: sigma size in voxel for smoothing to obtain bias field. (mandatory)</li><li><code>nbox</code>: Number of boxes in each dimension for the box-segmentation step.</li></ul><p>Larger sigma-values make the bias field smoother, but might not be able to catch the inhomogeneity. Smaller values can catch fast varying inhomogeneities but new inhomogeneities might be created. The stronger the bias field, the more boxes are required for segmentation. With too many boxes, it can happen that big darker structures are captured and appear overbrightened.</p><p>Calculates the bias field using the <code>boxsegment</code> approach. It assumes that there is a &quot;main tissue&quot; that is present in most areas of the object. Published in <a href="https://doi.org/10.1016/j.neuroimage.2021.118175">CLEAR-SWI</a>.</p><p>See also <a href="#MriResearchTools.getsensitivity"><code>getsensitivity</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/intensitycorrection.jl#L16-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.makehomogeneous!" href="#MriResearchTools.makehomogeneous!"><code>MriResearchTools.makehomogeneous!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">makehomogeneous(mag; sigma, nbox=15)</code></pre><p>Homogeneity correction of 3D arrays. 4D volumes are corrected using the first 3D volume to obtain the bias field.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>sigma</code>: sigma size in voxel for smoothing to obtain bias field. (mandatory)</li><li><code>nbox</code>: Number of boxes in each dimension for the box-segmentation step.</li></ul><p>Larger sigma-values make the bias field smoother, but might not be able to catch the inhomogeneity. Smaller values can catch fast varying inhomogeneities but new inhomogeneities might be created. The stronger the bias field, the more boxes are required for segmentation. With too many boxes, it can happen that big darker structures are captured and appear overbrightened.</p><p>Calculates the bias field using the <code>boxsegment</code> approach. It assumes that there is a &quot;main tissue&quot; that is present in most areas of the object. Published in <a href="https://doi.org/10.1016/j.neuroimage.2021.118175">CLEAR-SWI</a>.</p><p>See also <a href="#MriResearchTools.getsensitivity"><code>getsensitivity</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/intensitycorrection.jl#L16-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.mask_from_voxelquality" href="#MriResearchTools.mask_from_voxelquality"><code>MriResearchTools.mask_from_voxelquality</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mask_from_voxelquality(qmap::AbstractArray, threshold=:auto)</code></pre><p>Creates a mask from a quality map. Another option is to use <code>robustmask(qmap)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; qmap = romeovoxelquality(phase_3echo; TEs=[1,2,3]);
julia&gt; mask = mask_from_voxelquality(qmap);</code></pre><p>See also <a href="@ref"><code>ROMEO.romeovoxelquality</code></a>, <a href="@ref"><code>ROMEO.romeo</code></a>, <a href="#MriResearchTools.robustmask"><code>robustmask</code></a>, <a href="#MriResearchTools.brain_mask"><code>brain_mask</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/masking.jl#L96-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.mcpc3ds-Tuple{AbstractArray{&lt;:Real}}" href="#MriResearchTools.mcpc3ds-Tuple{AbstractArray{&lt;:Real}}"><code>MriResearchTools.mcpc3ds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mcpc3ds(phase, mag; TEs, keyargs...)

mcpc3ds(compl; TEs, keyargs...)

mcpc3ds(phase; TEs, keyargs...)</code></pre><p>Perform MCPC-3D-S coil combination and phase offset removal on 4D (multi-echo) and 5D (multi-echo, uncombined) input.</p><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>echoes</code>: only use the defined echoes. default: <code>echoes=[1,2]</code></li><li><code>sigma</code>: smoothing parameter for phase offsets. default: <code>sigma=[10,10,5]</code></li><li><code>bipolar_correction</code>: removes linear phase artefact. default: <code>bipolar_correction=false</code></li><li><code>po</code>: phase offsets are stored in this array. Can be used to retrieve phase offsets or work with memory mapping.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; phase = readphase(&quot;phase5D.nii&quot;)
julia&gt; mag = readmag(&quot;mag5D.nii&quot;)
julia&gt; combined = mcpc3ds(phase, mag; TEs=[4,8,12])</code></pre><p>For very large files that don&#39;t fit into memory, the uncombined data can be processed with memory mapped to disk:</p><pre><code class="language-julia-repl hljs">julia&gt; phase = readphase(&quot;phase5D.nii&quot;; mmap=true)
julia&gt; mag = readmag(&quot;mag5D.nii&quot;; mmap=true)
julia&gt; po_size = (size(phase)[1:3]..., size(phase,5))
julia&gt; po = write_emptynii(po_size, &quot;po.nii&quot;)
julia&gt; combined = mcpc3ds(phase, mag; TEs=[4,8,12], po)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/mcpc3ds.jl#L6-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.phase_based_mask-Tuple{Any}" href="#MriResearchTools.phase_based_mask-Tuple{Any}"><code>MriResearchTools.phase_based_mask</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phase_based_mask(phase; filter=true, threshold=1.0)</code></pre><p>Creates a mask from a phase image. Morphological filtering is activated by default. To return the mask before thresholding pass <code>threshold=nothing</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; phase_mask = phase_based_mask(phase);</code></pre><p>See also <a href="@ref"><code>ROMEO.romeovoxelquality</code></a>, <a href="@ref"><code>ROMEO.romeo</code></a>, <a href="#MriResearchTools.robustmask"><code>robustmask</code></a>, <a href="#MriResearchTools.brain_mask"><code>brain_mask</code></a></p><p>Original MATLAB algorithm:     se=strel(&#39;sphere&#39;,6);     L=del2(sign(wr));     test=convn(abs(L),se.Neighborhood,&#39;same&#39;);     PB=mask{1}.*(test&lt;500);     PB=imclose(PB,se);     mask{2}=round(imopen(PB,se));</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/masking.jl#L59-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.r2s_from_t2s-Tuple{Any}" href="#MriResearchTools.r2s_from_t2s-Tuple{Any}"><code>MriResearchTools.r2s_from_t2s</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">r2s_from_t2s(t2s) = 1000 ./ t2s</code></pre><p>Converts from T2* [ms] to R2* [1/s] values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/methods.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.readmag-Tuple{Any}" href="#MriResearchTools.readmag-Tuple{Any}"><code>MriResearchTools.readmag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">readmag(filename; rescale=false, keyargs...)</code></pre><p>Reads the NIfTI magnitude with sanity checking and optional rescaling to [0;1].</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mag = readmag(&quot;mag.nii&quot;)</code></pre><p><strong>Optional keyargs are forwarded to <code>niread</code>:</strong></p><pre><code class="nohighlight hljs">niread(file; mmap=false, mode=&quot;r&quot;)</code></pre><p>Read a NIfTI file to a NIVolume. Set <code>mmap=true</code> to memory map the volume.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/niftihandling.jl#L36-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.readphase-Tuple{Any}" href="#MriResearchTools.readphase-Tuple{Any}"><code>MriResearchTools.readphase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">readphase(filename; rescale=true, keyargs...)</code></pre><p>Reads the NIfTI phase with sanity checking and optional rescaling to [-π;π].</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; phase = readphase(&quot;phase.nii&quot;)</code></pre><p><strong>Optional keyargs are forwarded to <code>niread</code>:</strong></p><pre><code class="nohighlight hljs">niread(file; mmap=false, mode=&quot;r&quot;)</code></pre><p>Read a NIfTI file to a NIVolume. Set <code>mmap=true</code> to memory map the volume.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/niftihandling.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.robustmask" href="#MriResearchTools.robustmask"><code>MriResearchTools.robustmask</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">robustmask(weight::AbstractArray; factor=1, threshold=nothing)</code></pre><p>Creates a mask from an intensity/weight images by estimating a threshold and hole filling. It assumes that at least one corner is without signal and only contains noise. The automatic threshold is multiplied with <code>factor</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mask1 = robustmask(mag); # Using magnitude
julia&gt; mask2 = phase_based_mask(phase); # Using phase
julia&gt; mask3 = robustmask(romeovoxelquality(phase; mag)); # Using magnitude and phase
julia&gt; brain = brain_mask(robustmask(romeovoxelquality(phase; mag); threshold=0.9));</code></pre><p>See also <a href="@ref"><code>ROMEO.romeovoxelquality</code></a>, <a href="#MriResearchTools.phase_based_mask-Tuple{Any}"><code>phase_based_mask</code></a>, <a href="#MriResearchTools.brain_mask"><code>brain_mask</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/masking.jl#L31-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.robustmask!" href="#MriResearchTools.robustmask!"><code>MriResearchTools.robustmask!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">robustmask(weight::AbstractArray; factor=1, threshold=nothing)</code></pre><p>Creates a mask from an intensity/weight images by estimating a threshold and hole filling. It assumes that at least one corner is without signal and only contains noise. The automatic threshold is multiplied with <code>factor</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mask1 = robustmask(mag); # Using magnitude
julia&gt; mask2 = phase_based_mask(phase); # Using phase
julia&gt; mask3 = robustmask(romeovoxelquality(phase; mag)); # Using magnitude and phase
julia&gt; brain = brain_mask(robustmask(romeovoxelquality(phase; mag); threshold=0.9));</code></pre><p>See also <a href="@ref"><code>ROMEO.romeovoxelquality</code></a>, <a href="#MriResearchTools.phase_based_mask-Tuple{Any}"><code>phase_based_mask</code></a>, <a href="#MriResearchTools.brain_mask"><code>brain_mask</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/masking.jl#L31-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.robustrescale-Tuple{Any, Any, Any}" href="#MriResearchTools.robustrescale-Tuple{Any, Any, Any}"><code>MriResearchTools.robustrescale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">robustrescale(array, newmin, newmax; threshold=false, mask=trues(size(array)), datatype=Float64)</code></pre><p>Rescales the image to the the new range, disregarding outliers. Only values inside <code>mask</code> are used for estimating the rescaling option</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/utility.jl#L114-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.savenii-Tuple{AbstractArray, Any}" href="#MriResearchTools.savenii-Tuple{AbstractArray, Any}"><code>MriResearchTools.savenii</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">savenii(image::AbstractArray, filepath; header=nothing)

savenii(image::AbstractArray, name, writedir, header=nothing)</code></pre><p>Warning: MRIcro can only open images with types Int32, Int64, Float32, Float64</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; savenii(ones(64,64,5), &quot;image.nii&quot;)

julia&gt; savenii(ones(64,64,5), &quot;image2&quot;, &quot;folder&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/niftihandling.jl#L92-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.to_dim-Tuple{Real, Int64}" href="#MriResearchTools.to_dim-Tuple{Real, Int64}"><code>MriResearchTools.to_dim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_dim(V::AbstractVector, dim::Int)

to_dim(a::Real, dim::Int)</code></pre><p>Converts a vector or number to a higher dimension.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; to_dim(5, 3)
1×1×1 Array{Int64, 3}:
[:, :, 1] =
 5
julia&gt; to_dim([1,2], 2)
 1×2 Matrix{Int64}:
  1  2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/utility.jl#L151-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MriResearchTools.write_emptynii-Tuple{Any, Any}" href="#MriResearchTools.write_emptynii-Tuple{Any, Any}"><code>MriResearchTools.write_emptynii</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_emptynii(size, path; datatype=Float32, header=NIVolume(zeros(datatype, 1)).header)</code></pre><p>Writes an empty NIfTI image to disk that can be used for memory-mapped access.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; vol = write_emptynii((64,64,64), &quot;empty.nii&quot;)
julia&gt; vol.raw[:,:,1] .= ones(64,64) # synchronizes mmapped file on disk</code></pre><p>Warning: MRIcro can only open images with types Int32, Int64, Float32, Float64</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/korbinian90/MriResearchTools.jl/blob/7224ea639734a12ef8f784623330d8bb70bb0678/src/niftihandling.jl#L115-L127">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 8 June 2023 13:41">Thursday 8 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
